import { error, fail, redirect } from "@sveltejs/kit"
import type { Actions, PageServerLoad } from "./$types"
// Import Tables type if needed for stricter typing below
import type {
  Tables,
  Enums,
  TablesInsert,
} from "../../../../DatabaseDefinitions" // Adjusted path, added TablesInsert
import { z } from "zod" // For stricter validation
import { randomUUID } from "crypto" // For generating tokens

// Define a type for the combined member+profile structure
type TeamMemberWithProfile = Tables<"team_memberships"> & {
  profiles: Pick<Tables<"profiles">, "full_name" | "avatar_url"> | null
}

// --- Define assignable roles (excluding owner) ---
// Get roles from the Enums type generated by Supabase CLI
// Assuming your enum is named 'team_role'
const ASSIGNABLE_ROLES = ["admin", "member"] as const // Keep this for runtime check fallback
type AssignableRole = Extract<
  Enums<"team_role">,
  (typeof ASSIGNABLE_ROLES)[number]
>
const assignableRolesSet = new Set<string>(ASSIGNABLE_ROLES)

// --- Validation Schema ---
const emailSchema = z.string().email({ message: "Invalid email address" })

// --- Specific type for pending invites returned by load ---
// Use Pick to select only the needed fields from the full table definition
type PendingInvite = Pick<
  Tables<"team_invitations">,
  "id" | "invited_user_email" | "role" | "created_at"
>

export const load = (async ({
  locals: { supabase, supabaseServiceRole, session },
  params,
}) => {
  const { teamId } = params
  const userId = session?.user?.id

  if (!userId) {
    error(401, "Unauthorized")
  }

  // 1. Fetch team details
  const { data: team, error: teamError } = await supabase
    .from("teams")
    .select(`id, name, owner_user_id`)
    .eq("id", teamId)
    .single()

  if (teamError) {
    console.error("Error fetching team:", teamError)
    error(500, `Failed to load team details: ${teamError.message}`)
  }
  if (!team) {
    error(404, "Team not found")
  }

  // Check if the current user is the owner (needed for load AND actions)
  const isOwner = team.owner_user_id === userId

  // 2. Fetch basic team memberships
  const { data: memberships, error: membersError } = await supabase
    .from("team_memberships")
    .select(`role, user_id, team_id, created_at`)
    .eq("team_id", teamId)

  if (membersError) {
    console.error("Error fetching team members:", membersError)
    // Proceed, members might be empty or partially loaded if needed
  }

  // 3. Fetch profiles and combine
  let membersWithProfiles: TeamMemberWithProfile[] = []
  if (memberships && memberships.length > 0) {
    const memberUserIds = memberships.map((m) => m.user_id)
    // Use service role client here as regular users might not have permission
    // to view all profiles unless specific RLS is set up.
    const { data: profilesData, error: profilesError } =
      await supabaseServiceRole
        .from("profiles")
        .select(`id, full_name, avatar_url`)
        .in("id", memberUserIds)

    if (profilesError) {
      console.error(
        "Error fetching member profiles (using Service Role):",
        profilesError,
      )
      // Fallback: Map memberships without profile data
      membersWithProfiles = memberships.map((m) => ({ ...m, profiles: null }))
    } else {
      const profilesMap = new Map(
        profilesData.map((p) => [
          p.id,
          { full_name: p.full_name, avatar_url: p.avatar_url },
        ]),
      )
      membersWithProfiles = memberships.map((m) => ({
        ...m,
        profiles: profilesMap.get(m.user_id) ?? null,
      }))
    }
  }

  // 4. Fetch team projects
  const { data: projects, error: projectsError } = await supabase
    .from("projects")
    .select(`id, name`)
    .eq("owner_team_id", teamId)

  if (projectsError) {
    console.error("Error fetching team projects:", projectsError)
    // Proceed, projects might be empty
  }

  // 5. Fetch Pending Invitations (Only if owner or maybe admin in future?)
  // We only need pending invites if the user is the owner (to manage them)
  let pendingInvitations: PendingInvite[] = [] // Use the specific PendingInvite type
  if (isOwner) {
    // Select only the columns defined in PendingInvite
    const { data: invitesData, error: invitationsError } = await supabase
      .from("team_invitations")
      .select("id, invited_user_email, role, created_at") // Ensure select matches type
      .eq("team_id", teamId)
      .eq("status", "pending") // Only fetch pending ones
      .order("created_at", { ascending: false }) // Optional: order by date

    if (invitationsError) {
      console.error("Error fetching pending invitations:", invitationsError)
      // Decide how to handle this - maybe return empty array or throw?
      // For now, log and continue with empty array.
    } else {
      // Cast the result explicitly if Supabase types aren't precise enough,
      // but the select should ensure compatibility here.
      pendingInvitations = (invitesData as PendingInvite[]) ?? []
    }
  }

  return {
    team,
    members: membersWithProfiles,
    projects: projects ?? [],
    isOwner: isOwner, // Pass the calculated owner status
    pendingInvites: pendingInvitations, // Pass invitations to the page (now typed correctly)
  }
}) satisfies PageServerLoad

export const actions: Actions = {
  updateTeamName: async ({
    request,
    locals: { supabase, session },
    params,
  }) => {
    const formData = await request.formData()
    const newName = formData.get("teamName") as string
    const { teamId } = params
    const user = session?.user

    // Return the name field consistently on validation errors for this action
    const actionData = { action: "updateName", currentName: newName || null }

    if (!user) {
      return fail(401, {
        ...actionData,
        error: "Unauthorized",
        currentName: undefined,
      }) // Don't expose name on auth fail
    }

    if (
      !newName ||
      typeof newName !== "string" ||
      newName.trim().length === 0
    ) {
      return fail(400, {
        ...actionData, // Includes currentName
        error: "Team name cannot be empty",
      })
    }

    // Verify user is the owner before allowing update
    const { data: teamData, error: fetchError } = await supabase
      .from("teams")
      .select("owner_user_id")
      .eq("id", teamId)
      .single()

    // Reset currentName if the error is not about the name itself
    if (fetchError || !teamData) {
      console.error("Error fetching team for update check:", fetchError)
      return fail(404, {
        action: "updateName",
        error: "Team not found",
        currentName: undefined,
      })
    }

    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        action: "updateName",
        error: "Only the team owner can rename the team",
        currentName: undefined, // Reset currentName
      })
    }

    // Update the team name
    const { error: updateError } = await supabase
      .from("teams")
      .update({ name: newName.trim() })
      .eq("id", teamId)

    if (updateError) {
      console.error("Error updating team name:", updateError)
      return fail(500, {
        action: "updateName",
        error: "Failed to update team name",
        currentName: newName, // Keep name on server error for retry
      })
    }

    // Success case does not need currentName
    return {
      action: "updateName",
      success: true,
      message: "Team name updated successfully.",
    }
  },

  deleteTeam: async ({ locals: { supabase, session }, params }) => {
    const { teamId } = params
    const user = session?.user
    const actionData = { action: "deleteTeam" }

    if (!user) {
      return fail(401, { ...actionData, error: "Unauthorized" })
    }

    // Verify user is the owner before allowing delete
    const { data: teamData, error: fetchError } = await supabase
      .from("teams")
      .select("owner_user_id")
      .eq("id", teamId)
      .single()

    if (fetchError) {
      console.error("Error fetching team for deletion check:", fetchError)
      return fail(500, {
        ...actionData,
        error: "Could not verify team ownership.",
      })
    }
    if (!teamData) {
      return fail(404, { ...actionData, error: "Team not found" })
    }
    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        ...actionData,
        error: "Only the team owner can delete the team",
      })
    }

    // --- Deletion Logic ---
    // Ensure all related data is handled (e.g., ON DELETE CASCADE or manual cleanup)

    // 1. Delete pending invitations (optional, cascade might handle it)
    // const { error: inviteDeleteError } = await supabase
    //  .from('team_invitations')
    //  .delete()
    //  .eq('team_id', teamId);
    // if (inviteDeleteError) { /* handle error */ }

    // 2. Delete memberships (optional, cascade might handle it)
    // const { error: memberDeleteError } = await supabase
    //   .from('team_memberships')
    //   .delete()
    //   .eq('team_id', teamId);
    // if (memberDeleteError) { /* handle error */ }

    // 3. Handle projects (delete or reassign if FK restricts team deletion)
    const { count: projectCount, error: projectCheckError } = await supabase
      .from("projects")
      .select("id", { count: "exact", head: true })
      .eq("owner_team_id", teamId)

    if (projectCheckError) {
      console.error(
        "Error checking for projects before team delete:",
        projectCheckError,
      )
      return fail(500, {
        ...actionData,
        error: "Could not verify associated projects.",
      })
    }

    if (projectCount && projectCount > 0) {
      return fail(409, {
        // 409 Conflict
        ...actionData,
        error: `Cannot delete team. ${projectCount} project(s) are still associated with it. Please remove or reassign them first.`,
      })
    }

    // 4. Delete the team itself
    const { error: deleteError } = await supabase
      .from("teams")
      .delete()
      .eq("id", teamId)

    if (deleteError) {
      console.error("Error deleting team:", deleteError)
      // Provide a more specific message if it's a foreign key violation
      // (Might be caught by the project check above now, but keep as fallback)
      if (deleteError.code === "23503") {
        return fail(409, {
          ...actionData,
          error:
            "Cannot delete team. Ensure all associated items (like projects) are removed or reassigned first.",
        })
      }
      return fail(500, { ...actionData, error: "Failed to delete team." })
    }

    // Redirect to a safe page after deletion
    redirect(303, "/dashboard")
  },

  removeMember: async ({ request, locals: { supabase, session }, params }) => {
    const { teamId } = params
    const user = session?.user
    const formData = await request.formData()
    const memberUserId = formData.get("memberUserId") as string

    // Base action data for returns
    const baseActionData = { action: "removeMember" as const }

    // 1. Authentication & Basic Validation
    if (!user) {
      return fail(401, { ...baseActionData, error: "Unauthorized" })
    }
    if (!memberUserId) {
      // Add failedUserId: null for consistency if needed by client checks, otherwise omit
      return fail(400, { ...baseActionData, error: "Member User ID missing." })
    }

    // Action data specific to this potential failure point
    const actionDataWithError = {
      ...baseActionData,
      failedUserId: memberUserId,
    }

    // 2. Authorization: Verify caller is the team owner
    //    (RLS also enforces this, but belt-and-suspenders is good)
    const { data: teamData, error: teamFetchError } = await supabase
      .from("teams")
      .select("owner_user_id")
      .eq("id", teamId)
      .single()

    if (teamFetchError || !teamData) {
      console.error(
        "Error fetching team for remove member check:",
        teamFetchError,
      )
      // Omit failedUserId here as it's not specific to a user interaction failure
      return fail(404, {
        ...baseActionData,
        error: "Team not found or could not verify ownership.",
      })
    }

    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        ...actionDataWithError,
        error: "Only the team owner can remove members.",
      })
    }

    // 3. Prevent owner from removing themselves (RLS also prevents this)
    if (memberUserId === user.id || memberUserId === teamData.owner_user_id) {
      return fail(400, {
        ...actionDataWithError,
        error: "Team owner cannot be removed.",
      })
    }

    // 4. Database Operation: Delete the membership
    const { error: deleteError } = await supabase
      .from("team_memberships")
      .delete()
      .match({ team_id: teamId, user_id: memberUserId })

    if (deleteError) {
      console.error("Error removing team member:", deleteError)
      return fail(500, {
        ...actionDataWithError,
        error: "Failed to remove member.",
      })
    }

    // 5. Success: No specific data needed, enhance callback will invalidate
    //    Returning a success object is good practice though.
    return { ...baseActionData, success: true, removedUserId: memberUserId }
    // SvelteKit forms + enhance + invalidateAll will handle the UI update.
  },

  changeMemberRole: async ({
    request,
    locals: { supabase, session },
    params,
  }) => {
    const { teamId } = params
    const user = session?.user
    const formData = await request.formData()
    const memberUserId = formData.get("memberUserId") as string
    const newRole = formData.get("newRole") as string

    // Base action data for returns
    const baseActionData = { action: "changeMemberRole" as const }

    // 1. Authentication & Basic Validation
    if (!user) {
      return fail(401, { ...baseActionData, error: "Unauthorized" })
    }
    if (!memberUserId || !newRole) {
      return fail(400, {
        ...baseActionData,
        error: "Missing member ID or new role.",
        failedUserId: memberUserId ?? null, // Include if available
      })
    }

    // Action data with user context for errors
    const actionDataWithError = {
      ...baseActionData,
      failedUserId: memberUserId,
    }

    // 2. Validate the submitted role
    if (!assignableRolesSet.has(newRole)) {
      return fail(400, {
        ...actionDataWithError,
        error: `Invalid role specified. Must be one of: ${ASSIGNABLE_ROLES.join(", ")}`,
      })
    }
    const validatedRole = newRole as AssignableRole

    // 3. Authorization: Verify caller is the team owner
    const { data: teamData, error: teamFetchError } = await supabase
      .from("teams")
      .select("owner_user_id")
      .eq("id", teamId)
      .single()

    if (teamFetchError || !teamData) {
      console.error(
        "Error fetching team for role change check:",
        teamFetchError,
      )
      // General error, not specific to the user being edited
      return fail(404, {
        ...baseActionData,
        error: "Team not found or could not verify ownership.",
      })
    }

    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        ...actionDataWithError,
        error: "Only the team owner can change roles.",
      })
    }

    // 4. Prevent changing the owner's role (RLS also handles this, but good check)
    if (memberUserId === teamData.owner_user_id) {
      return fail(400, {
        ...actionDataWithError,
        error: "The team owner's role cannot be changed here.",
      })
    }

    // 5. Database Operation: Update the role
    const { error: updateError } = await supabase
      .from("team_memberships")
      .update({ role: validatedRole })
      .match({ team_id: teamId, user_id: memberUserId })

    if (updateError) {
      console.error("Error changing member role:", updateError)
      // Check if it was because the user wasn't found (though unlikely if listed)
      if (updateError.code === "PGRST204") {
        // PostgREST code for no rows updated/found
        return fail(404, {
          ...actionDataWithError,
          error: "Member not found in this team.",
        })
      }
      return fail(500, {
        ...actionDataWithError,
        error: "Failed to update member role.",
      })
    }

    // 6. Success
    return {
      ...baseActionData,
      success: true,
      updatedUserId: memberUserId,
      updatedRole: validatedRole,
    }
  },

  inviteMember: async ({ request, locals: { supabase, session }, params }) => {
    const { teamId } = params
    const user = session?.user
    const formData = await request.formData()
    const emailToInvite = formData.get("email") as string
    const roleToAssign = formData.get("role") as string

    const baseActionData = {
      action: "inviteMember" as const,
      email: emailToInvite, // Keep email for potential form repopulation
    }

    // 1. Authentication
    if (!user) {
      return fail(401, { ...baseActionData, error: "Unauthorized" })
    }

    // 2. Basic Input Validation
    if (!emailToInvite || !roleToAssign) {
      return fail(400, {
        ...baseActionData,
        error: "Email and role are required.",
      })
    }

    // 3. Email Format Validation
    const emailValidation = emailSchema.safeParse(emailToInvite)
    if (!emailValidation.success) {
      return fail(400, {
        ...baseActionData,
        error:
          emailValidation.error.errors[0]?.message ?? "Invalid email format.",
      })
    }
    const validatedEmail = emailValidation.data // Use the validated email

    // 4. Role Validation
    if (!assignableRolesSet.has(roleToAssign)) {
      return fail(400, {
        ...baseActionData,
        error: `Invalid role. Must be one of: ${ASSIGNABLE_ROLES.join(", ")}`,
      })
    }
    const validatedRole = roleToAssign as AssignableRole

    // 5. Authorization: Verify caller is the team owner
    //    (RLS also enforces this, but good practice)
    const { data: teamData, error: teamFetchError } = await supabase
      .from("teams")
      .select("owner_user_id, name") // Fetch name for email content later
      .eq("id", teamId)
      .single()

    if (teamFetchError || !teamData) {
      console.error("Error fetching team for invite check:", teamFetchError)
      return fail(404, {
        ...baseActionData,
        error: "Team not found or could not verify ownership.",
      })
    }

    // TODO: Add check for Admin role later if needed
    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        ...baseActionData,
        error: "Only the team owner can invite members.",
      })
    }

    // 6. Check if email belongs to an existing member of THIS team
    // First, find the user ID associated with the email, if any
    const { data: profileData, error: profileError } = await supabase
      .from("profiles")
      .select("id")
      .eq("email", validatedEmail) // Assuming email is unique in profiles
      .maybeSingle() // Use maybeSingle as they might not have a profile

    if (profileError) {
      console.error("Error fetching profile by email:", profileError)
      return fail(500, {
        ...baseActionData,
        error: "Error checking user existence.",
      })
    }

    if (profileData) {
      // User exists, now check if they are already in *this* team
      const { data: membership, error: membershipError } = await supabase
        .from("team_memberships")
        .select("user_id", { count: "exact", head: true }) // Just check existence
        .eq("team_id", teamId)
        .eq("user_id", profileData.id)

      if (membershipError) {
        console.error(
          "Error checking membership for existing user:",
          membershipError,
        )
        return fail(500, {
          ...baseActionData,
          error: "Error checking team membership.",
        })
      }

      if (membership) {
        return fail(409, {
          // 409 Conflict
          ...baseActionData,
          error: `${validatedEmail} is already a member of this team.`,
        })
      }
    }
    // If profileData is null or no membership found, proceed with invite check.

    // 7. Check for existing *pending* invitation for this email and team
    const { count: existingInviteCount, error: inviteCheckError } =
      await supabase
        .from("team_invitations")
        .select("id", { count: "exact", head: true })
        .eq("team_id", teamId)
        .eq("invited_user_email", validatedEmail)
        .eq("status", "pending")

    if (inviteCheckError) {
      console.error("Error checking existing invitations:", inviteCheckError)
      return fail(500, {
        ...baseActionData,
        error: "Could not verify existing invitations.",
      })
    }
    if (existingInviteCount && existingInviteCount > 0) {
      return fail(409, {
        // 409 Conflict
        ...baseActionData,
        error: `An invitation for ${validatedEmail} is already pending for this team.`,
      })
    }

    // 8. Generate Unique Token
    const invitationToken = randomUUID()

    // 9. Database Insert - Use TablesInsert for type safety
    const inviteData: TablesInsert<"team_invitations"> = {
      team_id: teamId,
      invited_by_user_id: user.id,
      invited_user_email: validatedEmail,
      role: validatedRole,
      token: invitationToken,
      // status defaults to 'pending' in DB
      // expires_at defaults in DB
    }

    const { error: insertError } = await supabase
      .from("team_invitations")
      .insert(inviteData)

    if (insertError) {
      console.error("Error inserting invitation:", insertError)
      // Check for unique constraint violation (duplicate pending invite)
      if (
        insertError.code === "23505" &&
        insertError.message.includes("unique_pending_invite")
      ) {
        // This check might be redundant due to step 7, but good fallback
        return fail(409, {
          ...baseActionData,
          error: `An invitation for ${validatedEmail} is already pending (database constraint).`,
        })
      }
      return fail(500, {
        ...baseActionData,
        error: "Failed to create invitation.",
      })
    }

    // 10. --- TODO: Invoke Supabase Edge Function to send email ---
    // We will need: validatedEmail, invitationToken, teamData.name, inviter's name (optional)
    console.log(
      `TODO: Send email to ${validatedEmail} with token ${invitationToken} for team ${teamData.name}`,
    )
    // Placeholder for actual function call
    // const { error: functionError } = await supabase.functions.invoke('send-invite-email', { ... })
    // if (functionError) { ... handle email failure ... }

    // 11. Return Success
    return {
      ...baseActionData,
      success: true,
      message: `Invitation sent successfully to ${validatedEmail}.`,
      email: undefined, // Clear email on success
    }
  },

  // --- NEW: revokeInvite action ---
  revokeInvite: async ({ request, locals: { supabase, session }, params }) => {
    const { teamId } = params
    const user = session?.user
    const formData = await request.formData()
    const invitationId = formData.get("invitationId") as string

    const baseActionData = {
      action: "revokeInvite" as const,
      failedInviteId: invitationId, // Track which one failed if needed
    }

    // 1. Authentication
    if (!user) {
      return fail(401, { ...baseActionData, error: "Unauthorized" })
    }

    // 2. Basic Input Validation
    if (!invitationId) {
      return fail(400, {
        ...baseActionData,
        error: "Invitation ID missing.",
        failedInviteId: null,
      })
    }

    // 3. Authorization: Verify caller is the team owner
    //    (Could also allow Admin in the future)
    const { data: teamData, error: teamFetchError } = await supabase
      .from("teams")
      .select("owner_user_id")
      .eq("id", teamId)
      .single()

    if (teamFetchError || !teamData) {
      console.error("Error fetching team for revoke check:", teamFetchError)
      return fail(404, {
        ...baseActionData,
        error: "Team not found or could not verify ownership.",
      })
    }

    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        ...baseActionData,
        error: "Only the team owner can revoke invitations.",
      })
    }

    // 4. Database Operation: Delete the invitation
    //    We delete it directly rather than changing status to 'revoked'
    //    Ensure we only delete PENDING invites for this team
    const { error: deleteError } = await supabase
      .from("team_invitations")
      .delete()
      .match({ id: invitationId, team_id: teamId, status: "pending" }) // Match all 3 for safety

    if (deleteError) {
      console.error("Error revoking invitation:", deleteError)
      return fail(500, {
        ...baseActionData,
        error: "Failed to revoke invitation.",
      })
    }

    // If the delete operation affected 0 rows (e.g., invite wasn't pending or didn't exist for this team)
    // It's generally okay, the result is the invite is gone. We could check the count if needed.
    // const { count } = await ...delete()...
    // if (count === 0) return fail(404, {...})

    // 5. Success
    return {
      ...baseActionData,
      success: true,
      message: "Invitation revoked successfully.",
      failedInviteId: undefined, // Clear on success
    }
  },
}
